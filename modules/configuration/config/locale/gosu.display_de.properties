ARRAY = Array
BEAN = Bean
BOOLEAN = Boolesch
DATETIME = Datum Uhrzeit
FUNCTION = Funktion
IDENTIFIER = Kennung
METATYPENAME = Typ
NULLTYPENAME = Null
NUMERIC = Nummer
STRING = Zeichenfolge
MSG_SYNTAX_ERROR = Syntaxfehler
MSG_BAD_IDENTIFIER_NAME = Symbol konnte nicht aufgelöst werden für\: {0}
MSG_END_OF_STMT = Ende der Anweisung erwartet. Operator ist möglicherweise falsch oder fehlt.
MSG_END_OF_EXPRESSION = Ende des Ausdrucks wird erwartet. Operator ist möglicherweise falsch oder fehlt.
MSG_EXPECTING_OPERATOR_TO_FOLLOW_EXPRESSION = Anweisung unvollständig. Nach dem Ausdruck wird nachfolgend ein Operator erwartet.
MSG_EXPECTING_ARGS = Argument[e] für Funktion {0} erwartet
MSG_EXPECTING_EXPRESSION_CLOSE = Zum Schließen des geklammerten Ausdrucks wird ")" erwartet.
MSG_EXPECTING_FUNCTION_CLOSE = Zum Schließen des Funktionsaufrufs wird ")" erwartet.
MSG_EXPECTING_TYPE_NAME = Typenname wird erwartet.
MSG_PARAMETERIZATION_NOT_SUPPORTED_FOR_TYPE = {0} unterstützt keine Parameterisierung.
MSG_NO_ARGUMENTS = Funktion {0} akzeptiert keine Argumente.
MSG_NULL_SYMBOL_TABLE = Symboltabelle ist null oder leer.
MSG_TYPE_MISMATCH = Typ "{1}" kann nicht in "{0}" konvertiert werden.
MSG_VALUE_MISMATCH = Unpassender Wert. Die Zeichenfolge "{0}" kann nicht in {1} konvertiert werden.
MSG_WRONG_NUM_OF_ARGS = Falsche Anzahl von Argumenten für Funktion {0}
MSG_EXPECTING_NAME_FUNCTION_DEF = Für die Funktion wird ein Name erwartet.
MSG_EXPECTING_LEFTPAREN_FUNCTION_DEF = Zum Öffnen der Deklaration der Funktionsargumente wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_FUNCTION_DEF = Zum Schließen der Deklaration der Funktionsargumente wird ")" erwartet.
MSG_EXPECTING_TYPE_FUNCTION_DEF = In der Funktionsdeklaration wird der Eintrag "\:" erwartet.
MSG_EXPECTING_TYPE_LITERAL_FUNCTION_DEF = In der Funktionsdeklaration wird nach dem Zeichen "\:" ein Typ erwartet.
MSG_EXPECTING_IDENTIFIER_FOREACH = Für die Anweisung "for...in" wird eine Kennung erwartet.
MSG_EXPECTING_IDENTIFIER_FOREACH_INDEX = Nach dem Schlüsselwort "Index" in der Anweisung "for...in" wird eine Kennung erwartet.
MSG_EXPECTING_IDENTIFIER_FOREACH_ITERATOR = Nach dem Schlüsselwort "Iterator" in der Anweisung "for...in" wird eine Kennung erwartet.
MSG_FOREACH_ITERATOR_NOT_ALLOWED = "iterator" ist für die Anweisung "for...in" ohne eine Loop-Variable nicht zulässig.
MSG_ITERATOR_SYMBOL_ONLY_SUPPORTED_ON_ITERABLE_OBJECTS = Das Symbol "Iterator" wird nur für wiederholbare Objekte unterstützt.
MSG_EXPECTING_IDENTIFIER_EXISTS = Für den Ausdruck "exists" wird eine Kennung erwartet.
MSG_EXPECTING_IDENTIFIER_EXISTS_INDEX = Nach dem Schlüsselwort "index" des Ausdrucks "exists" wird eine Kennung erwartet.
MSG_EXPECTING_IN_FOREACH = Für die Anweisung "for...in" wird der Eintrag "in" erwartet.
MSG_EXPECTING_LEFTPAREN_FE = In der Anweisung "for...in" wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_FE = In der Anweisung "for...in" wird ")" erwartet.
MSG_EXPECTING_LEFTPAREN_BLOCK = In der Blocktypendeklaration wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_BLOCK = In der Blocktypendeklaration wird ")" erwartet.
MSG_EXPECTING_COLON_BLOCK = In der Blocktypendeklaration wird "\:" erwartet.
MSG_EXPECTING_IN_EXISTS = Für den Ausdruck "exists" wird der Eintrag "in" erwartet.
MSG_EXPECTING_WHERE_EXISTS = Für den Ausdruck "exists" wird der Eintrag "where" erwartet.
MSG_EXPECTING_LEFTPAREN_EXISTS = Im Ausdruck "exists" wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_EXISTS = Im Ausdruck "exists" wird ")" erwartet.
MSG_EXPECTING_LEFTPAREN_EVAL = Zum Öffnen des Ausdrucks "eval" wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_EVAL = Zum Schließen des Ausdrucks "eval" wird ")" erwartet.
MSG_EXPECTING_LEFTPAREN_CATCH = Im Eintrag "catch" der Anweisung "try...catch...finally" wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_CATCH = Im Eintrag "catch" der Anweisung "try...catch...finally" wird ")" erwartet.
MSG_EXPECTING_IDENTIFIER_CATCH = Für den Eintrag "catch" der Anweisung "try...catch...finally" wird eine Kennung erwartet.
MSG_CATCH_OR_FINALLY_REQUIRED = In der Anweisung "try...catch...finally" wird der Eintrag "catch" oder "finally" erwartet.
MSG_EXPECTING_LEFTBRACE_STMTBLOCK = Zum Öffnen des Anweisungsblocks wird '{' erwartet.
MSG_EXPECTING_RIGHTBRACE_STMTBLOCK = Zum Schließen des Anweisungsblocks wird "}" erwartet.
MSG_EXPECTING_LEFTPAREN_IF = Zum Öffnen der "if"-Bedingung wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_IF = Zum Schließen der "if"-Bedingung wird ")" erwartet.
MSG_EXPECTING_LEFTPAREN_SWITCH = Zum Öffnen des Ausdrucks "switch" wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_SWITCH = Zum Schließen des Ausdrucks "switch" wird ")" erwartet.
MSG_EXPECTING_LEFTPAREN_WHILE = Zum Öffnen der "while"-Bedingung wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_WHILE = Zum Schließen der "while"-Bedingung wird ")" erwartet.
MSG_EXPECTING_LEFTPAREN_EXCEPT = Zum Öffnen der "except"-Bedingung wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_EXCEPT = Zum Schließen der "except"-Bedingung wird ")" erwartet.
MSG_EXPECTING_WHILE_DO = Zum Schließen der Anweisung "do...while" wird der Eintrag "while" erwartet.
MSG_LOOP_DOESNT_LOOP = Loop wiederholt sich nicht.
MSG_EXPECTING_EQUALS_ASSIGN = Für eine Zuweisung wird "\=" erwartet.
MSG_EXPECTING_EXPRESSSION_ON_RHS = Für die Zuweisungsanweisung wird ein gültiger "rhs"-Ausdruck erwartet.
MSG_EXPECTING_STATEMENT = Anweisung wird erwartet.
MSG_EXPECTING_BEANTYPE = Für den Mitglieds-Zugriff wird ein komplexer Typ erwartet. Gefunden\: {0}
MSG_EXPECTING_ARRAYTYPE_FOREACH = Nach dem Eintrag "in" der Anweisung "for...in" wird ein Typ erwartet, über den iteriert werden kann. Gefunden\: {0}
MSG_EXPECTING_ARRAYTYPE_EXISTS = Nach dem Eintrag "in" des Ausdrucks "exists" wird ein Array-Typ erwartet. Gefunden\:
MSG_EXPECTING_IDENTIFIER_ARG_TYPE = Nach "\:" wird für das Funktionsargument ein Typenname erwartet.
MSG_EXPECTING_ARRAY_BRACKET = Es wird "]" erwartet, um die Deklaration des Array-Typenliterals zu schließen.
MSG_EXPECTING_NEW_ARRAY_OR_CTOR = Um einen neuen Array- oder Objektvorgang einzuleiten, wird "[" oder "(" erwartet.
MSG_EXPECTING_OPEN_BRACE_FOR_NEW_ARRAY = Zum Starten einer Array-Wertausdrucksliste wird "{{" erwartet.
MSG_EXPECTING_CLOSE_BRACE_FOR_NEW_ARRAY = Zum Beenden einer Array-Wertausdrucksliste wird "}" erwartet.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE = Zum Schließen der Deklaration eines parameterisierten Typenliterals wird ">" erwartet.
MSG_EXPECTING_CLOSING_ANGLE_BRACKET_FOR_TYPE_VAR_LIST = Zum Schließen einer Typenvariablenliste wird ">" erwartet.
MSG_COULD_NOT_PARAMETERIZE = Parameterisierung nicht möglich.
MSG_EXPECTING_OPEN_BRACE_FOR_SWITCH = Zum Öffnen der "switch"-Anweisung wird "{{" erwartet.
MSG_EXPECTING_CLOSE_BRACE_FOR_SWITCH = Zum Schließen der "switch"-Anweisung wird "}" erwartet.
MSG_EXPECTING_COLON_TERNARY = Für einen konditionalen ternären Ausdruck wird "\:" erwartet.
MSG_EXPECTING_REFERENCE_TYPE = Es wird ein Referenztyp erwartet. Ein primitiver Typ ist hier nicht zulässig.
MSG_LOSS_OF_PRECISION_IN_CONDITIONAL_EXP = Typen können nicht ohne Genauigkeitsverlust konvertiert werden. Konvertieren Sie sie explizit.
MSG_EXPECTING_CASE_COLON = Zum Schließen des "case"-Ausdrucks wird ")" erwartet.
MSG_DUPLICATE_CASE_EXPRESSION = Duplikat des "case"-Ausdrucks.
MSG_TYPE_MISMATCH_IN_CONDIITIONAL_EXP = Unpassender Typ in bedingtem ternärem Ausdruck.
MSG_EXPECTING_IDENTIFIER_VAR = Variablenname wird erwartet.
MSG_EXPECTING_VAR_STMT = "var"-Deklaration wird erwartet.
MSG_EXPECTING_TYPELITERAL = Auf der rechten Seite des Ausdrucks wird die Angabe ein Typenliteral erwartet.
MSG_EXPECTING_TYPELITERAL_OR_NAMESPACE = Typenliteral oder Namensraum wird erwartet.
MSG_PRIMITIVES_NOT_ALLOWED_HERE = Ein primitiver Typ ist hier nicht zulässig.
MSG_INCONVERTIBLE_TYPES = Nicht konvertierbare Typen; {0} kann nicht in {1} konvertiert werden
MSG_BAD_NAMESPACE = "{0}" ist kein gültiger Namensraum.
MSG_EXPECTING_ARRAYLENGTH = Array-Eigenschaft "length" wird erwartet.
MSG_ENTITYBEANS_ARE_IMMUTABLE = Die Eigenschaft des Objekts kann nicht direkt geändert werden.
MSG_MULTIPLE_DEFAULT_CLAUSES_NOT_PERMITTED = Mehrere "default"-Einträge in "switch"-Anweisung erkannt
MSG_CASE_CLAUSE_MAY_NOT_FOLLOW_DEFAULT_CLAUSE = Nach einem "default"-Eintrag darf kein "case"-Eintrag folgen.
MSG_METHOD_NOT_VISIBLE = Die Funktion "{0}" ist mit den momentanen Sichtbarkeitsbeschränkungen des Parsers nicht sichtbar.
MSG_PROPERTY_NOT_VISIBLE = Die Eigenschaft "{0}" ist mit den momentanen Sichtbarkeitsbeschränkungen des Parsers nicht sichtbar.
MSG_OBJECT_RETIRED = Die ID "{0}" verweist auf ein nicht mehr aktives Objekt.
MSG_OBJECT_LITERALS_DEPRECATED = Entitätsliterale sind veraltet, verwenden Sie stattdessen einen Query Builder.
MSG_DEPRECATED_MEMBER = {0} in {1} ist veraltet.
MSG_EXPECTING_ENTITY_TYPE = Im "find"-Ausdruck wird der Name eines Entitätstyps erwartet.
MSG_EXPECTING_QUERY_PATH = Es wird ein Ausdruck mit Abfragepfad erwartet.
MSG_QUERY_PATH_MUST_BEGIN_WITH = Der Ausdruck mit Abfragepfad muss mit {0} beginnen.
MSG_EXPECTING_CONDITIONAL_EXPRESSION = Konditionaler Ausdruck wie "a > b" wird erwartet.
MSG_CONDITIONAL_EXPRESSION_EXPECTS_BOOLEAN = Boolescher Wert erwartet
MSG_EXPECTING_IDENTIFIER_FIND = Für "find"-Ausdruck wird eine Kennung erwartet.
MSG_EXPECTING_IN_FIND = Für "find"-Ausdruck wird der Eintrag "in" erwartet.
MSG_EXPECTING_WHERE_FIND = Für "find"-Ausdruck wird der Eintrag "where" erwartet.
MSG_EXPECTING_LEFTPAREN_FIND = Im "find"-Ausdruck wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_FIND = Im "find"-Ausdruck wird ")" erwartet.
MSG_QUERYPATH_MUST_BEGIN_WITH = Der Abfragepfad muss mit dem übergeordneten Abfrageausdruck "{0}" beginnen.
MSG_QUERY_IN_LHS_OP_NOT_ENTITY = {0} kann nicht als Entitätstyp aufgelöst werden. Links vom "in"-Operator ist eine Eigenschaft eines Entitätstyps erforderlich.
MSG_QUERY_IN_LHS_OP_NOT_ARRAY = {0} hat keinen passenden Array-Typ. Links vom "in"-Operator muss eine Eigenschaft eines Entitätstyps stehen, die einen gültigen Array-Typ besitzt.
MSG_QUERY_EXPECTED_BOOLEAN_EXPRESSION = {0} ist kein Boolescher Ausdruck.
MSG_EXPECTING_READONLY_ENTITY_TYPE = "find" ist auf schreibgeschützte Entitätstypen begrenzt. Setzen Sie das Registrierungselement "allow-entity-queries" , um beschreibbare Entitäten zu finden.
MSG_STR_IMMUTABLE = Zeichenfolgen sind nicht veränderbar.
MSG_UNTERMINATED_STRING_LITERAL = Nicht abgeschlossene Zeichenfolge. "." wird erwartet.
MSG_INVALID_CHAR_AT = Unzulässiges Escape-Zeichen an Position {0}
MSG_FUNCTION_CLASH_PARAMS = "{0}" in "{1}" steht mit "{2}" in "{3}" in Konflikt. Beide Funktionen haben die gleiche Löschung, jedoch überschreibt keine die andere
MSG_UNTERMINATED_COMMENT = Nicht abgeschlossener Kommentar. "*/" wird erwartet.
MSG_UNEXPECTED_EOF = Unerwartetes Dateiende
MSG_FUNCTION_ALREADY_DEFINED = {0} ist bereits in {1} definiert.
MSG_FUNCTION_CLASH = "{0}" in "{1}" steht mit "{2}" in "{3}" in Konflikt. Rückgabetypen nicht kompatibel.
MSG_ATTEMPTING_TO_ASSIGN_WEAKER_ACCESS_PRIVILEGES = "{0}" in "{1}" steht mit "{2}" in "{3}" in Konflikt. Es wird versucht, schwächere Zugriffsrechte zuzuweisen.
MSG_CANNOT_OVERRIDE_FINAL = Die als final deklarierte Mitglieds-Methode "{0}" aus "{1}" kann nicht überschrieben werden.
MSG_CANNOT_ASSIGN_VALUE_TO_FINAL_VAR = Kann der finalen Variablen " {0}" keinen Wert zuweisen.
MSG_VAR_MIGHT_NOT_HAVE_BEEN_INIT = Variable "{0}" wurde möglicherweise noch nicht initialisiert.
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT = Variable "{0}" wurde möglicherweise bereits initialisiert
MSG_VAR_MIGHT_ALREADY_HAVE_BEEN_INIT_LOOP = Variable "{0}" wurde möglicherweise bereits in Loop initialisiert.
MSG_FUNCTION_ALREADY_DEFINED_IN_EXTENDED_CLASS = {0} ist bereits definiert. Funktionen können nicht durch Erweiterungen überschrieben werden.
MSG_DUPLICATE_CLASS_FOUND = Duplizierte Klasse gefunden in\: {0}.
MSG_DUPLICATE_TYPE_FOUND = Duplizierter Typ gefunden in\: {0}.
MSG_DUPLICATE_ENHANCEMENT_FOUND = Duplizierte Erweiterung gefunden in\: {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CLASS_DEF = Zum Öffnen der "class"-Anweisung wird "{{" erwartet.
MSG_EXPECTING_CLOSE_BRACE_FOR_CLASS_DEF = Zum Schließen der "class"-Anweisung wird "}" erwartet.
MSG_EXPECTING_NAME_CLASS_DEF = Ein Name für die Klasse wird erwartet.
MSG_EXPECTING_ENHANCEMENT_DEF = Eine Erweiterung wird erwartet.
MSG_NAMESPACE_CLASS_CONFLICT = Der Verzeichnispfad der Klasse entspricht nicht dem Paketnamen.
MSG_NO_SUCH_FUNCTION = Keine Funktion für {0} definiert
MSG_CANNOT_EXTEND_PRIMITIVE_TYPE = Ein primitiver Typ {0} kann nicht erweitert werden.
MSG_CANNOT_EXTEND_FINAL_TYPE = Der als final deklarierte Typ {0} kann nicht erweitert werden.
MSG_ENHANCEMENTS_CANNOT_ENHANCE_OTHER_ENHANCEMENTS = Die Erweiterung {0} kann nicht erweitert werden.
MSG_CYCLIC_INHERITANCE = Zyklische Vererbung einschließlich {0}.
MSG_EXPECTING_OPEN_BRACE_FOR_CONSTRUCTOR_DEF = Zum Öffnen des Konstruktor-Hauptteils wird "{{" erwartet.
MSG_EXPECTING_OPEN_BRACE_FOR_FUNCTION_DEF = Zum Öffnen des Funktions-Hauptteils wird "{{" erwartet.
MSG_EXPECTING_CLOSE_BRACE_FOR_FUNCTION_DEF = Zum Schließen des Funktions-Hauptteils wird "}" erwartet.
MSG_EXPECTING_CLOSE_BRACE_FOR_CONSTRUCTOR_DEF = Zum Schließen des Konstruktor-Hauptteils wird "}" erwartet.
MSG_NO_DEFAULT_CTOR_IN = Kein Standardkonstruktor in {0} vorhanden.
MSG_WRONG_NAMESPACE = Der Paketname "{0}" stimmt nicht dem Verzeichnis "{1}" überein.
MSG_WRONG_CLASSNAME = Der Klassenname {0} stimmt nicht mit der Datei {1} überein.
MSG_SAME_NAME_AS_CLASS = "{0}" ist bereits als Klassenname für diese Datei definiert
MSG_EXPECTING_PROPERTY_GET_OR_SET_MODIFIER = Für die Eigenschaft wird "get" oder "set" als Modifikator der Eigenschaft erwartet.
MSG_EXPECTING_NAME_PROPERTY = Für die Variable wird ein Eigenschaftsname erwartet.
MSG_PROPERTY_ALREADY_DEFINED = Eigenschaft "{0}" ist bereits definiert.
MSG_GETTER_FOR_PROPERTY_ALREADY_DEFINED = "get"-Funktion der Eigenschaft bereits für "{0}" definiert
MSG_SETTER_FOR_PROPERTY_ALREADY_DEFINED = "set"-Funktion der Eigenschaft bereits für "{0}" definiert
MSG_PROPERTY_NOT_WRITABLE = "{0}" ist schreibgeschützt.
MSG_CLASS_PROPERTY_NOT_READABLE = Eigenschaft "{0}" der Klasse "{1}" kann nicht gelesen werden.
MSG_CLASS_PROPERTY_NOT_WRITABLE = Eigenschaft "{0}" der Klasse "{1}" ist schreibgeschützt.
MSG_NO_VIEWS_FOR_YOUS = Es werden keine Ansichten unterstützt. Erwägen Sie, eine Abfrage gegenüber "{0}" durchzuführen.
MSG_VARIABLE_ALREADY_DEFINED = {0} ist bereits definiert. Bitte verwenden Sie einen anderen Namen.
MSG_FUNCTION_DECL_MISSING = Interner Fehler. Symbol der Deklarationsfunktion für {0} nicht gefunden.
MSG_EXPECTING_DEFAULT_VALUE = Standardwertzuweisung wird erwartet. Die erforderlichen Parameter müssen vor den optionalen Parametern stehen.
MSG_DEFAULT_VALUE_NOT_ALLOWED = Hier ist kein Standardwert zulässig
MSG_COMPILE_TIME_CONSTANT_REQUIRED = Ausdruck muss an dieser Stelle über eine konstante Kompilationszeit verfügen.
MSG_OVERLOADING_NOT_ALLOWED_WITH_OPTIONAL_PARAMS = Überladen mit optionalen Parametern nicht zulässig
MSG_MISSING_REQUIRED_ARGUMENTS = Eines oder mehrere erforderliche Argumente fehlen
MSG_ARGUMENT_ALREADY_DEFINED = Argument ist bereits definiert
MSG_EXPECTING_NAME_PARAM = Parametername wird erwartet
MSG_EXPECTING_NAMED_ARG = Ein bezeichnetes Argument wird erwartet
MSG_PARAM_NOT_FOUND = Parameter nicht gefunden
MSG_VARIABLE_REQUEST_DOES_NOT_ALLOW_VALUE = Anforderungs-Variablen können keinen Anfangswert haben.
MSG_VARIABLE_TYPE_OR_VALUE_REQUIRED = Für "var"-Anweisung wird ein "als" und/oder "\:" erwartet.
MSG_VARIABLE_MUST_HAVE_NON_NULL_TYPE = Variablen dürfen nicht vom Typ Null sein. Fügen Sie für diese Variable einen expliziten Typen hinzu.
MSG_CONDITION_IS_ALWAYS_TRUE_FALSE = Die Bedingung ist immer {0}
MSG_VOID_NOT_ALLOWED = Typ "void" ist hier nicht zulässig.
MSG_FUNCTIONS_NOT_ALLOWED_IN_THIS_CONTEXT = Funktionsdeklarationen sind in diesem Kontext nicht zulässig.
MSG_CONSTRUCTORS_NOT_ALLOWD_IN_THIS_CONTEXT = Konstruktoren sind in diesem Kontext nicht zulässig.
MSG_INNER_CLASSES_NOT_ALLOWED_IN_THIS_CONTEXT = Deklarationen von inneren Klassen sind in diesem Kontext nicht zulässig.
MSG_NO_SOURCE_FOUND = Keine Quelle für die Klasse gefunden.
MSG_CANNOT_RETURN_VALUE_FROM_VOID = Rückgabe eines Werts für eine Funktion, die "void" als Rückgabewert deklariert, ist nicht möglich.
MSG_RETURN_NOT_ALLOWED_HERRE = Die Anweisung "return" ist hier nicht zulässig.
MSG_MISSING_RETURN_VALUE = Rückgabewert fehlt.
MSG_EXPECTING_DECL = Es wird die Deklaration einer Variablen, Funktion oder Eigenschaft erwartet.
MSG_FUNCTION_ARG_NAME_CONFLICTS_WITH_CLASS_VAR = Das Argument "{0}" der Funktion {1} steht mit einem Klassenfeld in Konflikt.
MSG_EXPECTING_ARROW_AFTER_BLOCK_ARGS = Nach Blockargumentdeklarationen wird "->" erwartet.
MSG_EXPECTING_CLOSE_BRACE_FOR_BLOCK = Nach einer Blockanweisungsliste wird "}" erwartet.
MSG_EXPECTING_ARROW_AFTER_MAP_KEY = Nach Blockargumentdeklarationen wird "->" erwartet.
MSG_UNEXPECTED_ARROW = Unerwartet '->' in Listeninitialisierung
MSG_EXPECTING_CLOSE_BRACE_FOR_INITIALIZER = Nach einer Initialisierungsanweisung wird "}" erwartet.
MSG_MODIFIER_ABSTRACT_NOT_ALLOWED_HERE = Der Modifikator "abstract" ist hier unzulässig.
MSG_ABSTRACT_METHOD_CANNOT_BE_ACCESSED_DIRECTLY = Kein direkter Zugriff auf abstrakte Methode "{0}"
MSG_NOT_ALLOWED_IN_INTERFACE = In Schnittstelle unzulässig
MSG_UNIMPLEMENTED_METHOD = Funktion {0} nicht implementiert\: {1}
MSG_INHERITS_UNRELATED_DEFAULTS = {0} Vererbt nicht verbundene Standardwerte für {1} aus {2} und {3}
MSG_INHERITS_ABSTRACT_AND_DEFAULT = {0} vererbt abstrakte und standardmäßige Methoden für {1} von {2} und {3}
MSG_INTERFACE_CANNOT_EXTEND_CLASS = Eine Schnittstelle kann nur Schnittstellen, aber keine Klasse erweitern.
MSG_CLASS_CANNOT_EXTEND_INTERFACE = Eine Klasse kann keine Schnittstelle erweitern.
MSG_CANNOT_EXTEND_ARRAY = "Eine Klasse kann keinen Array erweitern."
MSG_CLASS_MUST_HAVE_PACKAGE = Eine Klasse muss ein Paket haben.
MSG_CLASS_CANNOT_IMPLEMENT_CLASS = Eine Klasse kann keine Klasse implementieren.
MSG_ENUM_CANNOT_EXTEND_CLASS = Eine Aufzählung kann keine Klasse erweitern.
MSG_ENUM_CANNOT_HAVE_ANNOTATIONS = Eine Aufzählungskonstante darf nicht über Annotationen verfügen.
MSG_ENUM_CONSTRUCTOR_MUST_BE_PRIVATE = Der Aufzählungskonstruktor muss als privat deklariert werden.
MSG_ENUM_CONSTRUCTOR_NOT_ACCESSIBLE = Auf den Aufzählungskonstruktor kann hier nicht zugegriffen werden
MSG_ENUM_MAY_NOT_HAVE_TYPEPARAM = Aufzählung verfügt evtl. nicht über Typenparameter.
MSG_BAD_CAPTURE_TYPE = Blöcke unterstützen keine lexikalische Referenz auf diesem Symboltyp. Weisen Sie den Symboltyp einer lokalen Variable außerhalb des Blocks zu, um darauf zu verweisen.
MSG_POTENTIALLY_BAD_CAPTURE = Diese Kennung erfasst eine externe Variable, die die "out of scope"-Erfassung nicht vollständig unterstützt.  Es kann ein Laufzeitfehler auftreten, wenn die Kennung Bewertungen außerhalb der äußersten Funktionsreichweite vornimmt.
MSG_CANNOT_CAPTURE_SYMBOL_IN_BLOCK_IN_ANON_CLASS = In einem Block, der sich innerhalb einer anonymen Klasse befindet, können keine Symbole erfasst werden.
MSG_CANNOT_CAPTURE_SYMBOL_IN_ANON_CLASS_IN_BLOCK = In einer anonymen Klasse, die sich innerhalb eines Blocks befindet, können keine Symbole erfasst werden.
MSG_EXPECTING_ENHANCE_KEYWORD = "enhance" wird erwartet.
MSG_NON_PRIVATE_MEMBERS_MUST_DECLARE_TYPE = Mitglieds-Variablen, die nicht privat sind, müssen explizit einen Typ deklarieren.
MSG_DELEGATES_CANNOT_BE_STATIC = Delegates können nicht statisch sein.
MSG_DELEGATE_METHOD_CONFLICT = Delegate-Mitglieder-Konflikt\: {0} und {1}. Implementieren Sie das Mitglied explizit, um den Konflikt zu lösen.
MSG_DELEGATES_SHOULD_NOT_SELF_DELEGATE = Delegates können nicht selbst-delegierend sein.
USING_INTERNAL_CLASS = Dies ist eine interne Klasse, die später geändert wird.  Die Verwendung dieser Klasse <b>birgt ein Risiko und wird nicht unterstützt</b>.
MSG_EXTENSION_CLASS_NOT_FOUND = Zu erweiternde Klasse {0} nicht gefunden.
MSG_CANNOT_DEREF_PROPERTIES_IN_WHERE = Die Eigenschaft in des Eintrags "where" kann nicht dereferenziert werden. Verwenden Sie ggf. den Eintrag "exists".
MSG_CANNOT_CALL_METHOD_WITH_WILDCARD_PARAM = Funktion mit Platzhalterparametern kann nicht aufgerufen werden.
MSG_NO_WILDCARDS = Platzhalter sind in Gosu veraltet. Ersetzen Sie bitte den Typparameter durch "{0}"
MSG_EXPECTING_COLON_ENHANCEMENT = "\:" in Erweiterung erwartet.
MSG_EXPECTING_CLOSE_BRACKET_FOR_LIST_LITERAL = Am Ende eines Listenliterals wird "]" erwartet.
MSG_CANNOT_PARAMETERIZE_NONGENERIC = Nicht generischer Typ kann nicht parameterisiert werden.
MSG_TYPE_PARAM_NOT_ASSIGNABLE_TO = Typparameter {0} kann nicht dem Bindungstyp {1} zugewiesen werden.
MSG_TYPE_NOT_ANNOTATION = Typ {0} ist keine Annotation  Es muss die Schnittstelle gw.lang.IAnnotation implementiert werden.
MSG_MISPLACED_META_ANNOTATION = Diese Annotation kann nur auf eine Annotations-Klasse angewendet werden.
MSG_MISPLACED_ANNOTATION = Diese Annotation kann nicht auf eine Annotations-Klasse angewendet werden.
MSG_ANNOTATION_WHEN_NONE_ALLOWED = Annotation "{0}" darf nicht in der Deklaration {1} vorkommen.
MSG_ANNOTATION_USE_SITE_TARGET_NOT_ALLOWED_HERE = Annotation "{0}" hat ungültiges use-site-Ziel "{1}" für den Kontext.
MSG_TOO_MANY_ANNOTATIONS = Annotation "{0}" darf nur einmal in der Deklaration {1} enthalten sein.
MSG_EXPECTING_COLON_ANNOTATION = '\:' wird erwartet, um use-site-Ziel und Annotationstyp zu trennen.
MSG_INVALID_TYPE = "{0}" ist kein gültiger Typ.
MSG_INVALID_GENERIC_EXCEPTION = Generische Klassen können "java.lang.Throwable" nicht erweitern.
MSG_INVALID_INNER_TYPE = Keine innere Klasse "{0}" für "{1}" gefunden.
MSG_INVALID_TYPE_WITH_QUALIFIED_NAME = "{0}" hat einen ungültigen Typ\: "{1}".
MSG_NOT_A_STATEMENT = Dies ist keine Anweisung.
MSG_CANNOT_CONSTRUCT_ABSTRACT_CLASS = "{0}" ist abstrakt und kann nicht erstellt werden.
MSG_CANNOT_CONSTRUCT_RECURSIVE_CLASS = "{0}" ist rekursiv; kann nicht direkt konstruiert werden.
MSG_RECURSIVE_CONSTRUCTOR = Abruf eines rekursiven Konstruktors.
MSG_MISSING_RETURN = Rückgabeanweisung fehlt.
MSG_UNREACHABLE_STMT = Anweisung nicht erreichbar
MSG_BREAK_OUTSIDE_SWITCH_OR_LOOP = Die Anweisung "break" ist hier nicht zulässig.
MSG_CONTINUE_OUTSIDE_LOOP = Die Anweisung "continue" ist hier nicht zulässig.
MSG_PROPERTY_SET_MUST_HAVE_ONE_PARAMETER = Methoden zum Setzen von Eigenschaften (setter) dürfen genau einen Parameter besitzen.
MSG_PROPERTY_SET_MUST_RETURN_VOID = Methoden zum Setzen von Eigenschaften (setter) müssen "void" als Rückgabewert haben.
MSG_MISSING_PROPERTY_RETURN = Rückgabetyp für Eigenschaft fehlt.
MSG_IMPLICIT_COERCION_WARNING = Hier erfolgt eine implizite erzwungene Typenumwandlung vom Typ {0} zum Typ {1}.  Erwägen Sie den Typ explizit anzugeben mit der Anweisung "as {1}"
MSG_IMPLICIT_COERCION_ERROR = {0} muss ausdrücklich mit dem Schlüsselwort "as" in {1} konvertiert werden.
MSG_ASYMMETRICAL_COMPARISON = Asymmetrischer Vergleich zwischen {0} und {1}. Wandeln Sie u. U. einen der Operanden um.
MSG_SILLY_ASSIGNMENT = Hier wird {0}  sich selbst zugewiesen.  Dies könnte unbeabsichtigt vorkommen und einem Programmfehler zuzuordnen sein.
MSG_UNUSED_VARIABLE = {0} wird nicht verwendet.
MSG_LIKELY_JAVA_CAST = Dies scheint eine Typenumwandlung im Java-Stil zu sein, die keine korrekte Gosu-Syntax darstellt.  Um das Ergebnis eines Ausdrucks in einen anderen Typ umzuwandeln, fügen Sie nach dem Ausdruck "as {0}" hinzu.
MSG_UNEXPECTED_TOKEN = Unerwartetes Token\: {0}
MSG_EXPECTING_INT_ACCESS_TO_ARR_ETC = Für Arrays, Sammlungen oder Strings wird ein indexbasierter Zugriff mit Ganzzahlen über den Array-Operator [] erwartet.
MSG_EXPECTING_BEAN_TYPE_WITH_REFLECTION_OPERATOR = Ein Bean-Typ mit dem "[]" Reflexions-Operator wird erwartet.
MSG_PROPERTY_REFLECTION_ONLY_WITH_STRINGS = Reflexion für Eigenschaften von Beans kann nur mit Strings durchgeführt werden.
MSG_EXPECTING_BRACKET_TO_CLOSE_DYNAMIC_MEMBER_ACCESS = Zum Schließen des Ausdrucks für den dynamischen Zugriff auf Objekt-Elemente  wird der Operator "]" erwartet.
MSG_WRONG_NUMBER_OF_ARGS_TO_FUNCTION = Falsche Anzahl von Argumenten für Funktion {0}.  {1} erwartet, {2} zurückgegeben.
MSG_WRONG_NUMBER_OF_ARGS_TO_CONSTRUCTOR = Falsche Anzahl von Argumenten für Konstruktor {0}.  {1} erwartet, {2} zurückgegeben.
MSG_SHOULD_HAVE_FOUND_METHOD_AT_LINE = Es sollte eine Funktion in Zeile {0}, Spalte {1}, gefunden werden.
MSG_VOID_EXPRESSION_NOT_ALLOWED = Ausdrücke an dieser Position dürfen nicht leer sein.
MSG_EXPECTING_RETURN_TYPE_OR_FUN_BODY = Rückgabetyp oder Funktions-Hauptteil erwartet.
MSG_INVALID_TYPE_FOR_ANNOTATION_MEMBER = Ungültiger Typ für Annotationsmitglied
MSG_ERRANT_TYPE_VAR = Fehlerhafte Typenvariable
MSG_USING_VOID_RETURN_TYPE_FROM_NON_NULL_EXPR = "void" wird als Rückgabewert für einen Ausdruck verwendet, der nicht null ist.
MSG_FIELD_TYPE_HAS_NOT_BEEN_INFERRED = Der Typ dieses Felds wurde noch nicht ermittelt, weshalb das Feld nicht verwendet werden kann.  Dieser Ausdruck muss nach der Felddeklaration angegeben werden.
MSG_BEAN_CLASS_IS_NULL = Bean-Klasse ist null.
MSG_BEAN_MEMBER_PATH_IS_NULL = Der Pfad aller Mitglieder des Beans ist null.
MSG_BEAN_MEMBER_PATH_IS_EMPTY = Der Pfad aller Mitglieder des Beans ist leer.
MSG_NO_EXPLICIT_TYPE_INFO_FOUND = Keine explizite Typeninformation für {0} gefunden
MSG_NO_CONSTRUCTOR_FOUND_FOR_CLASS = Kein Konstruktor für Klasse {0} gefunden
MSG_WRONG_NUMBER_OF_ARGS_FOR_METHOD_ON_CLASS = Falsche Anzahl von Argumenten für die Funktion {0} der Klasse {1}
MSG_NO_METHOD_DESCRIPTOR_FOUND_FOR_METHOD = Keine Beschreibung der Funktion (Deskriptor) für die Funktion {0} der Klasse {1} gefunden
MSG_METHOD_IS_NOT_STATIC = Funktion "{0}" ist nicht statisch in der Klasse {1}
MSG_METHOD_IS_STATIC = Funktion "{0}" ist statisch in der Klasse {1}
MSG_NO_PROPERTY_DESCRIPTOR_FOUND = Kein Deskriptor {0} zur Beschreibung der Eigenschaft {1} der Klasse {2} gefunden
MSG_NO_TYPE_ON_NAMESPACE = Typ {0} nicht in Paket {1} gefunden
MSG_ANY = {0}
MSG_EXPECTING_MEMBER_ACCESS_PATH = Pfad für Zugriff auf Mitglieder  wird erwartet.
MSG_CANNOT_CREATE_NEW_ARRAY_FROM_TYPE_VAR = Ein neues Instanz-Array kann nicht über eine Variable eines bestimmten Typs erzeugt werden. Auf diesen Typ kann nur ein Schreibzugriff erfolgen.
MSG_NOT_A_VALID_EXCEPTION_TYPE = {0} erweitert Throwable nicht und kann nicht abgefangen werden.
MSG_CANNOT_INFER_ARGUMENT_TYPE_AT_THIS_POSTION = Das Argument {0} muss eine Typendeklaration bereitstellen, da der Typ nicht ermittelt werden kann.
MSG_OBSOLETE_CTOR_SYNTAX = Diese Konstruktorsyntax ist veraltet. Verwenden Sie stattdessen das Schlüsselwort "construct".
MSG_OBSOLETE_NOT_EQUAL_OP = Der Operator <> ist veraltet und muss durch \!\= ersetzt werden
MSG_MUST_BE_IN_OUTER_TO_CONSTRUCT_INNER = Man muss sich in der Klasse {0} befinden oder von dieser Klasse ableiten, um eine nicht-statische innere Klasse {1} zu definieren.
MSG_TYPE_DOES_NOT_HAVE_EMPTY_CONSTRUCTOR = Der Typ {0} hat keinen Standardkonstruktor und kann hier nicht implizit erstellt werden.
MSG_ENHANCEMENT_DOES_NOT_ACCEPT_THIS_STATEMENT = Erweiterungen können keine Anweisungen dieses Typs haben.
MSG_CANNOT_OVERRIDE_FUNCTIONS_IN_ENHANCEMENTS = Die Funktion "{0}" ist bereits im Typ {1} definiert.  Erweiterungen dürfen Funktionen nicht überschreiben.
MSG_CANNOT_OVERRIDE_PROPERTIES_IN_ENHANCEMENTS = Die Eigenschaft "{0}" ist bereits im Typ {1} definiert.  Erweiterungen können keine Eigenschaften überschreiben.
MSG_ENHANCED_TYPE_MUST_USE_ENHANCEMENT_TYPEVARS = Erweiterter Typ muss alle Typenvariablen nutzen, die durch die Erweiterung deklariert werden.
MSG_ABSTRACT_MEMBER_NOT_IN_ABSTRACT_CLASS = Abstraktes Mitglied ist nicht in einer abstrakten Klasse definiert.
MSG_ILLEGAL_USE_OF_MODIFIER = Unzulässige Verwendung des Modifikator. "{0}" kann hier nicht mit "{1}" verwendet werden.
MSG_ILLEGAL_FORWARD_REFERENCE = Illegaler Vorwärtsverweis
MSG_MISSING_OVERRIDE_MODIFIER = Modifikator "override" fehlt. Funktion {0} überschreibt und/oder implementiert die Funktion von {1}.
MSG_RENAME_METHOD = Funktion muss umbenannt werden. Funktion {0} steht im Konflikt mit der Funktion von {1}, Rückgabetypen sind inkompatibel. Private Funktionen kompilieren mit 'internem' Zugriff, daher verursachen sie zur Laufzeit Konflikte, wenn sie sich im gleichen Paket befinden.
MSG_STATIC_METHOD_CANNOT_OVERRIDE = Die statische Funktion {0} kann die Funktion in {1} nicht überschreiben/implementieren.
MSG_OVERRIDES_OBJECT_METHOD = Standardmethode {0} überschreibt Objektmethode
MSG_INHEREITED_WITH_DIFF_ARG_TYPES = "{0}" kann nicht mit verschiedenen Typenargumenten vererbt werden\: {1}
MSG_NO_IMPLEMENTS_ALLOWED = Für die Schnittstelle ist kein Implementierungseintrag zulässig.
MSG_NO_EXTENDS_ALLOWED = Für die Annotation ist kein Erweiterungseintrag zulässig.
MSG_FUNCTION_NOT_OVERRIDE = Funktion {0} überschreibt nichts.
MSG_FUNCTION_NOT_OVERRIDE_PROPERTY = Funktion {0} überschreibt nichts. Möchten Sie vielleicht die Eigenschaft "{1}" überschreiben?
MSG_PROPERTY_OVERRIDES_WITH_INCOMPATIBLE_TYPE = Die Eigenschaft wird mit inkompatiblem Typ überschrieben
MSG_SUBCLASS_OBJECT = {0} erweitert explizit Objekt.
MSG_AMBIGUOUS_SYMBOL_REFERENCE = Dies ist eine mehrdeutige Referenz. Bitte geben Sie das Symbol als vollqualifizierten Namen an.
MSG_LIST_TO_ARRAYLIST_WARNING = Implizite erzwungene Typenumwandlung zu ArrayList. Bitte verwenden Sie ArrayList explizit.
MSG_VAR_CASE_MISMATCH = Die Variable "{0}" wird unter Missachtung der korrekten Groß- und Kleinschreibung referenziert.  Bitte ändern Sie diesen Verweis zu "{1}".
MSG_FUNCTION_CASE_MISMATCH = Die Funktion "{0}" wird unter Missachtung der korrekten Groß- und Kleinschreibung referenziert.  Bitte ändern Sie diesen Verweis zu "{1}".
MSG_PROPERTY_CASE_MISMATCH = Die Eigenschaft "{0}" wird unter Missachtung der korrekten Groß- und Kleinschreibung referenziert.  Bitte ändern Sie diesen Verweis zu "{1}".
MSG_TYPE_CASE_MISMATCH = Der Typ "{0}" wird unter Missachtung der korrekten Groß- und Kleinschreibung referenziert.  Bitte ändern Sie diesen Verweis zu "{1}".
MSG_NON_STATIC_ACCESS_OF_STATIC_MEMBER = Die Eigenschaft "{0}" ist statisch, wird innerhalb des Typs {1} aber nicht statisch referenziert.
MSG_NON_STATIC_ACCESS_WITH_IDENTIFIER_OF_STATIC_MEMBER = Die Eigenschaft "{0}" ist statisch, wird jedoch nicht direkt vom Typ {1} referenziert.  \nEs gibt einen Konflikt mit der Variable oder Eigenschaft mit dem Namen "{2}".  Bitte geben Sie den Ausdruck als vollqualifizierten Namen {3}.{0} an.
MSG_STATEMENT_ON_SAME_LINE = Mehrere Anweisungen in derselben Zeile. Dies weist möglicherweise auf einen unbeabsichtigten logischen Fehler hin.\nVerschieben Sie die Anweisungen ggf. in eine neue Zeile.
MSG_MUST_BE_DEFINED_AS_CLASS = Muss als "class" definiert sein.
MSG_VOID_RETURN_IN_CTX_EXPECTING_VALUE = Bei dieser Funktion wird erwartet, dass der Block einen Wert zurückgibt.
MSG_NO_STATIC_CONSTRUCTOR = Konstruktoren dürfen nicht statisch sein.
MSG_NO_ABSTRACT_METHOD_CALL_IN_CONSTR = Funktion {0} ist abstrakt und kann nicht im Konstruktor aufgerufen werden.
MSG_CALLING_OVERRIDABLE_FROM_CTOR = Überschreibbare Funktion wird von Konstruktor aufgerufen\: {0}
MSG_AMBIGUOUS_METHOD_INVOCATION = Dieser Funktionsaufruf ist mehrdeutig.
MSG_RETURN_VAL_FROM_VOID_FUNCTION = Sie versuchen, einen Wert aus einer Funktion mit Rückgabetyp "void" zurückzugeben.
MSG_BAD_ANONYMOUS_CLASS_DECLARATION = Nur Java- und Gosu-Typen können anonym erweitert werden.
MSG_SINGLE_ANON_CTOR = Eine anonyme Klasse darf maximal einen Konstruktor definieren
MSG_ANON_CTOR_PARAMS_CONFLICT_WITH_CALL_SITE = Anonyme Konstruktorparametertypen treten mit Argumenttypen auf der Abrufseite in Konflikt
MSG_ASSIGNMENT_IN_IF_STATEMENT = Zuweisungen in if-Bedingungen sind unzulässig.
MSG_ASSIGNMENT_IN_LOOP_STATEMENT = Zuweisungen in Loop-Bedingungen sind unzulässig.
MSG_JAVA_STYLE_VARIABLE_DECLARATION = Dies ist eine Java-Deklaration einer Variablen.  Verwenden Sie stattdessen das Schlüsselwort "var".
MSG_NUMERIC_TYPE_EXPECTED = Numerischer Ausdruck erwartet.
MSG_GETTER_CANNOT_HAVE_PARAMETERS = Die Definition eines Zugriffs auf eine Eigenschaft über "get" kann keine Parameter enthalten.
MSG_BAD_TEMPLATE_DIRECTIVE = Ungültige Vorlagenanweisung. Gültige Anweisungen sind "extends" und "params".
MSG_CLASSPATH_STATEMENT_EXPECTS_A_STRING = In der classpath-Anweisung muss eine Zeichenfolge für den Pfad angegeben werden.
MSG_COMMA_IS_THE_CLASSPATH_SEPARATOR = Die classpath-Anweisung verwendet Kommas als plattformunabhängige Pfadtrennzeichen.
MSG_BITSHIFT_LHS_MUST_BE_INT_OR_LONG = Der linke Operand muss "int" oder "long" sein.
MSG_BITWISE_OPERAND_MUST_BE_INT_OR_LONG = Der bit-weise logische Operand muss "int" oder "long" sein.
MSG_EXPECTING_LEFTPAREN_USING = Zum Öffnen des Prädikats "using" wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_USING = Zum Schließen des Prädikats "using" wird ")" erwartet.
MSG_BAD_TYPE_FOR_USING_STMT = Das Prädikat der using-Anweisung muss vom Typ Closeable, IDisposable oder Lock sein. Für eine Synchronisierung im Java-Stil muss zu IMonitorLock konvertiert werden.
MSG_UNNECESSARY_COERCION = Dieser Ausdruck hat bereits den Typ {0} und daher ist eine Typenumwandlung zu {1} unnötig.
MSG_LATER_ASSIGNMENT_MAKES_EXPRESSION_ILLEGAL = Eine spätere Zuweisung zu {0} erlaubt keine automatische Ableitung des Typs mehr, welche hier verwendet werden kann.
WSDL_DUPLICATE_WEB_SERVICE = Der Name des Webdienstes existiert zweifach. Es kann nur ein Webdienst mit diesem Namen definiert sein.
MSG_NUMBER_LITERAL_TOO_LARGE = Angegebene Zahlen-Konstante zu groß.
WSDL_DUPLICATE_METHOD = Doppelt vorhandene Webdienst-Funktionen. Überladene Funktionen müssen selbst bei unterschiedlichen Parametertypen eine andere Anzahl von Parametern haben.\n{0} steht mit {1} in Konflikt.
WSDL_NOT_WEBSERVICE = Diese Annotation steht nur im Webdienst zur Verfügung.
WSDL_UNSUPPORTED_TYPE = Der Webdienst kann nicht auf den folgenden nicht unterstützten Typ verweisen\: {0} {1}
WSDL_REFERENCE_ABSTRACT_CLASS = Der Webdienst kann nicht auf eine abstrakte Klasse verweisen\: {0} {1}
WSDL_REFERENCE_INTERFACE = Der Webdienst kann nicht auf eine Schnittstelle verweisen\: {0} {1}
WSDL_REFERENCE_ANNOTATION = Der Webdienst kann nicht auf eine Annotation verweisen\: {0} {1}
WSDL_REFERENCE_TRANSACTION_TYPE = Der Webdienst kann nicht auf einen Typ im Namensraum gw.transaction.* verweisen\: {0} {1}
WSDL_REFERENCE_LIST = Der Webdienst kann nicht auf Listentypen verweisen\: {0}.  Verwenden Sie stattdessen ein Array mit einem starken Typ (z. B. String[]). {1}
WSDL_REFERENCE_MAP = Der Webdienst kann nicht auf Map-Typen verweisen\: {0} {1}
WSDL_REFERENCE_COLLECTION = Der Webdienst kann nicht auf Sammlungs-Typen verweisen\: {0}.  Verwenden Sie stattdessen ein Array mit einem starken Typ (z. B. String[]). {1}
WSDL_REFERENCE_PARAMETERIZED_TYPE = Der Webdienst kann nicht auf parameterisierte Typen verweisen\: {0}
WSDL_REFERENCE_GENERIC_TYPE = Der Webdienst kann nicht auf generische Typen verweisen\: {0} {1}
WSDL_REFERENCE_UNSUPPORTED_NAMESPACE = Der Webdienst kann nicht auf den folgenden Typ verweisen. Dies ist Teil eines nicht unterstützten Namensraums. Nur Typen des Namensraums  "gw.*" (außer gw.transaction.*) sind zulässig\: {0} {1}
WSDL_REFERENCE_CLASS_WITHOUT_DEFAULT_CONSTRUCTOR = Die Klasse {0} hat keinen Standardkonstruktor und kann nicht von einem Webdienst referenziert werden. {1}   //Dies könnte eine Warnung sein.
WSDL_REFERENCE_WEBSERVICE = Der Webdienst kann nicht auf andere Webdiensttypen verweisen\: {0} {1}
WSDL_REFERENCE_SOAP_TYPE = Webdienste können nicht auf Typen im Namensraum soap.* verweisen\: {0} {1}
WSDL_REFERENCE_XML_TYPE = RPC-Webdienste können sich nicht auf Typen auf xml-Grundlage beziehen\: {0} {1}
WSDL_READONLY_PROPERTIES = Webdienste sollten nicht auf Typen mit schreibgeschützten Eigenschaften verweisen.  \nDiese Typen können nicht als Parameter für einen Webdienst-Aufruf gesetzt werden. {0} {1}
WSDL_WRITEONLY_PROPERTIES = Webdienste sollten nicht auf Typen verweisen, die Eigenschaften mit Nur-Schreibzugriff besitzen.  \nDiese Typen können nicht als Rückgabewert eines Webdienst-Aufrufs gesetzt werden. {0} {1}
WSDL_REFERENCE_CAUSES_NAMESPACE_COLLISION = Dieser Typ verursacht einen Namensraum-Konflikt bei einem Webdienst.\nDiese beiden Typen haben denselben relativen Namen und würden für Webdienste im selben Namensraum soap.*{0} veröffentlicht.\nBenennen Sie einen der folgenden Typen um, oder achten Sie darauf, dass in keinem Webdienst auf diesen Typ verwiesen wird\: {1} und {2}.  {3}
MSG_DELEGATION_NOT_ALLOWED_HERE = Übertragung von Aufgaben mittels Delegates ist hier nicht erlaubt.
MSG_DELEGATE_MUST_NOT_BE_STATIC = Statische Übertragung von Aufgaben mittels Delegates wird hier nicht unterstützt.
MSG_DELEGATES_REPRESENT_INTERFACES_ONLY = Ein Delegate kann nur Schnittstellentypen darstellen.
MSG_ONLY_INTERFACES_ALLOWED_HERE = Hier nur Schnittstellen zulässig
MSG_ONLY_ONE_CLASS_IN_COMPONENT_TYPE = In einem Komponententyp ist nur eine Nicht-Schnittstelle zulässig.
MSG_ONLY_ONE_TYPE_VARIABLE = Auf eine Typenvariable dürfen keine Verbindlichkeiten folgen
MSG_NO_ARRAY_IN_COMPONENT_TYPE = Arrays sind nicht in einem Komponententyp erlaubt
MSG_NO_PRIMITIVE_IN_COMPONENT_TYPE = Primitivtypen sind in einem Komponententyp nicht erlaubt
MSG_COMPOUND_TYPE_NOT_ALLOWED_HERE = Zusammengesetzte Typen sind hier unzulässig.
MSG_PARAMETERIZED_TYPE_NOT_ALLOWED_HERE = Parameterisierte Typen sind hier unzulässig
MSG_DYNAMIC_TYPE_NOT_ALLOWED_HERE = Dynamische Typen sind hier unzulässig.
MSG_CANNOT_EXTEND_INTERNAL_JAVATYPE = Der Java-Typ {0} verfügt über Package-gesicherten Zugriff und kann in Gosu nicht erweitert oder verbessert werden.
MSG_CLASS_DOES_NOT_IMPL = Delegierte Schnittstelle nicht von Erklärungstyp {0} implementiert\:
MSG_EXPECTING_REPRESENTS = Für ein Delegate wird das Schlüsselwort "represents" erwartet.
MSG_EXPECTING_LEFTPAREN_AGGREGATE = Zum Öffnen des zusammengesetzten Typs wird "(" erwartet.
MSG_EXPECTING_RIGHTPAREN_AGGREGATE = Zum Schließen des  zusammengesetzten Typs wird ")" erwartet.
MSG_MEMBER_ACCESS_REQUIRED_FOR_SUPER = Mitgliederzugriff erforderlich für 'super'
MSG_ALREADY_CONTAINS_TYPE = Der Typ {0} ist bereits angegeben.
MSG_OVERRIDING_FUNCTION_MUST_HAVE_SAME_NUMBER_OF_TYPE_VARS = Um bei dieser Funktion die übergeordnete Funktion korrekt zu überschreiben, müssen {0} Typenvariablen vorhanden sein.
MSG_AGGREGATES_MUST_CONTAIN_MORE = Ein zusammengesetzter Typ muss mehr als einen Typ beinhalten.
MSG_INTERFACE_REDUNDANT = Schnittstelle {0} ist redundant, {1} erweitert {0}.
MSG_NONTERMINAL_CASE_CLAUSE = Die vorherige Eintrag "case" ist nicht abgeschlossen. Möglicherweise fehlt eine "break"-, "continue"- oder "return"-Anweisung.
MSG_ANONYMOUS_CLASS_NOT_ALLOWED_HERE = Anonyme Klasse hier unzulässig
MSG_PARAMETERIZED_ARRAY_COMPONENT = Parameterisierter Array-Komponententyp verliert bei Laufzeit Typenparameter.
MSG_TEMPLATE_EXCEPTION_GENERATED_SOURCE = erstellter Quellcode
MSG_TEMPLATE_MISSING_END_TAG_SCRIPTLET = End-Tag "%>" für Scriptlet fehlt.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION = End-Tag "%>" für Ausdruck fehlt.
MSG_TEMPLATE_MISSING_END_TAG_EXPRESSION_ALT = End-Tag "}" für Ausdruck fehlt.
MSG_TEMPLATE_MULTIPLE_PARAMS = Mehrere "params"-Anweisungen gefunden.
MSG_TEMPLATE_INVALID_PARAMS = Ungültige Parameter\: {0}
MSG_TEMPLATE_UNKNOWN_DIRECTIVE = Unbekannte Anweisung {0}. Gültige Anweisungen sind "params" und "extends".
MSG_EQUALS_FOR_INITIALIZER_EXPR = In dieser Objektinitialisierung wird "\=" erwartet.
MSG_INITIALIZER_NOT_ALLOWED_ABSTRACT_PROPERTY = Initializer in abstrakter Eigenschaft nicht erlaubt.
MSG_EXPECTING_NAME_VALUE_PAIR = Es wird der Name einer Eigenschaft gefolgt von "\=" und dem Wert eines Ausdrucks erwartet.
MSG_REDUNTANT_INITIALIZERS = Die Eigenschaft {0} hat bereits einen Initialisierungswert.
MSG_ONLY_ONE_COLON_IN_INITIALIZERS = Vor dem Namen einer Eigenschaft in Initialisierungsblöcken kann maximal ein Doppelpunkt stehen.
MSG_EXPECTING_PROPERTY_NAME = Eigenschaftsname wird erwartet.
MSG_BLOCK_TYPES_SHOULD_HAVE_ARG_NAMES = Blocktypenparameter müssen Namen angeben und die Syntax "argName\:Type" haben.
MSG_DIMENSION_MULTIPLICATION_UNDEFINED = Multiplikation zwischen verschiedenen Einheiten ist nicht definiert.
MSG_DIMENSION_ADDITION_MUST_BE_SAME_TYPE = Beide Operanden müssen als Einheit denselben als final deklarierten Typ haben.
MSG_DIMENSION_DIVIDE_SCALAR_BY_DIMENSION = Ein reiner Zahlenwert kann nicht durch eine Zahl mit Einheit dividiert werden.
MSG_DIMENSION_MUST_BE_FINAL = Bei der Arithmetik mit Einheiten müssen als final deklarierte Typen verwendet werden. {0} ist nicht als final deklariert
MSG_DIMENSION_NONSTANDARD_NUMBER_NO_OVERRIDE = Keine Grundrechenarten bei Abmessungen, {0}, mit nicht dem Standard entsprechenden Zahlentyp, {1}
MSG_RELATIONAL_OPERATOR_CANNOT_BE_APPLIED_TO_TYPE = Der relationale Operator "{0}" kann nicht auf den Typ {1} angewendet werden.
MSG_ARITHMETIC_OPERATOR_CANNOT_BE_APPLIED_TO_TYPES = Operator "{0}" kann nicht auf "{1}", "{2}" angewendet werden
MSG_ASSIGNMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = Zuweisungen im Hauptteil eines Blocks müssen zwischen geschweifte Klammern gesetzt werden.
MSG_BLOCKS_CAN_HAVE_A_MOST_SIXTEEN_ARGS = Blöcke dürfen maximal 16 Arg. enthalten.
MSG_BLOCKS_LITERAL_NOT_ALLOWED_IN_NEW_EXPR = Blockliterale sind in einem neuen Ausdruck nicht zulässig.
MSG_STATEMENTS_MUST_BE_ENCLOSED_IN_CURLIES_IN_BLOCKS = "{0}"-Anweisungen im Hauptteil eines Blocks müssen zwischen geschweifte Klammern gesetzt werden.
MSG_NOT_AN_ENHANCEABLE_TYPE = {0} unterstützt keine Erweiterungen.
MSG_CANNOT_REFERENCE_CLASS_TYPE_VAR_IN_STATIC_CONTEXT = Variablen eines Klassentyps können nicht in einem statischen Kontext referenziert werden.
MSG_CANNOT_REFERENCE_THIS_IN_STATIC_CONTEXT = "Dies" kann nicht in einem statischen Kontext referenziert werden.
MSG_CANNOT_CALL_NON_STATIC_METHOD_FROM_STATIC_CONTEXT = Nicht statische Methoden können nicht in einem statischen Kontext referenziert werden.
MSG_CANNOT_REFERENCE_NON_STATIC_PROPERTY_FROM_STATIC_CONTEXT = Nicht statische Eigenschaften können nicht in einem statischen Kontext referenziert werden.
MSG_CANNOT_REFERENCE_NON_STATIC_FEATURE_HERE = Sie können hier nicht auf eine nicht statische Funktion verweisen
MSG_ONLY_GOSU_JAVA_TYPES = Nur Gosu- und Java-Typen sind hier zulässig
MSG_CANNOT_READ_A_WRITE_ONLY_PROPERTY = Eigenschaften mit Nur-Schreibzugriff dürfen nur geschrieben werden.
MSG_TYPE_IS_NOT_ITERABLE = Für den Erweiterungsoperator {0} wird ein Typ erwartet, über den iteriert werden kann.
MSG_INTERVAL_MUST_BE_ITERABLE_HERE = Intervalltyp muss hier wiederholbar sein.
MSG_EXTRA_DOT_FOUND_IN_INTERVAL = Intervall-Operator verfügt über zwei Punkte, drei gefunden
MSG_EXPECTING_NUMBER_TO_FOLLOW_DECIMAL = Es wird eine Dezimalzahl erwartet.
MSG_IMPROPER_VALUE_FOR_NUMERIC_TYPE = Der Wert {0} liegt nicht innerhalb der Domain der Zahlen vom Typ {1}.
MSG_PRIMITIVE_TYPE_PARAM = Der primitive Typ {0} ist hier unzulässig. Typ {0} wird implizit als Typenparameter in {1} transformiert. Verwenden Sie bitte {1} direkt.
MSG_CTOR_HAS_XXX_ACCESS = Konstruktor hat {0}-Zugriff
MSG_TYPE_HAS_XXX_ACCESS = Typ "{0}" hat {1}-Zugriff.
MSG_QUERY_SPECIFY_COLUMN = Geben Sie eine Abfragespalte an.
MSG_QUERY_SPECIFY_QUERY_COLUMN = {0} muss eine abfragbare Spalte in der Datenbank angeben.
MSG_CANNOT_EXTEND_RAW_GENERIC_TYPE = Der generische Typ "{0}" erfordert Typenargumente.
MSG_TYPE_VAR_VARIANCE_ERROR = Die Typenvariable {0} ist als "{1}" deklariert, aber wird in einer "{2}"-Position mit Typ {3} verwendet
MSG_SUPER_CLASS_METHOD_NAME_SAME_AS_SUBCLASS = Die Methode "{0}" der Oberklasse steht mit dem internen Konstruktornamen dieser Klasse in Konflikt. Ändern Sie bitte den Namen der Methode der Oberklasse oder diesen Klassennamen.
MSG_NOT_A_SUPERTYPE = {0] ist kein direkter übergeordneter Typ
MSG_CALL_TO_SUPER_THIS_MUST_BE_FIRST = Der Aufruf von "{0}()" muss die erste Anweisung im Konstruktor sein.
MSG_EXPECTING_OPERATOR_TO_FOLLOW_NEW_EXPRESSION = Anweisung unvollständig. Nach dem "new"-Ausdruck wird nachfolgend ein Operator erwartet.
MSG_EXPECTING_TYPE_TO_FOLLOW_PACKAGE_NAME = Nach dem Paketnamen wird ein Typ erwartet.
MSG_QUERY_FUNCTION_EXPRESSION_RESTRICTION = Nur Verweise auf Datenbankspalten oder DBFunction-Methodenaufrufe zulässig
MSG_QUERY_ORDER_BY_EXPRESSION = Nur Ausdrücke für den Zugriff auf Elemente, die Datenbankspalten enthalten, sind zulässig.
MSG_QUERY_ARRAYS_NOT_ALLOWED = Der Zugriff auf einen Array ist hier nicht zulässig.
MSG_APPLICATION_MODIFIER_HAS_BEEN_DEPRECATED = Der Modifier "application" ist veraltet. Verwenden Sie stattdessen das Objekt gw.api.web.Scopes.Application.
MSG_SESSION_MODIFIER_HAS_BEEN_DEPRECATED = Der Modifier "session" ist veraltet. Verwenden Sie stattdessen gw.api.web.SessionVar.
MSG_REQUEST_MODIFIER_HAS_BEEN_DEPRECATED = Der Modifier "request" ist veraltet. Verwenden Sie stattdessen gw.api.web.RequestVar.
MSG_EXECUTION_MODIFIER_HAS_BEEN_DEPRECATED = Der Modifikator "execution" wurde verworfen und ist bedeutungslos.  Er kann entfernt werden.
MSG_CANNOT_REFERENCE_OUTER_SYMBOL_WITHIN_ENHANCEMENTS = Das äußere Schlüsselwort kann nicht innerhalb von Erweiterungen referenziert werden.  Verschieben Sie diese anonyme Klasse ggf. in eine benannte Klasse.
MSG_CANNOT_REFERENCE_ENCLOSING_PROPERTIES_WITHIN_ENHANCEMENTS = Methoden des diesen Typ umgebenden Typs können nicht innerhalb von Erweiterungen referenziert werden.  Verschieben Sie diese anonyme Klasse ggf. in eine benannte Klasse.
MSG_CANNOT_REFERENCE_ENCLOSING_METHODS_WITHIN_ENHANCEMENTS = Methoden des diesen Typ umgebenden Typs können nicht innerhalb von Erweiterungen referenziert werden.  Verschieben Sie diese anonyme Klasse ggf. in eine benannte Klasse.
MSG_INVALID_LITERAL = Dieses Literal kann nicht in {0} konvertiert werden. Sie müssen den Wert explizit festlegen.
MSG_PROPERTIES_MUST_AGREE_ON_STATIC_MODIFIERS = Die Getter und Setter der Eigenschaften müssen beide entweder statisch oder nicht statisch sein.
MSG_PROPERTIES_MUST_AGREE_ON_TYPE = Die Getter und Setter der Eigenschaften müssen mit dem Typ der Eigenschaft übereinstimmen.
MSG_NO_ENCLOSING_INSTANCE_IN_SCOPE = Keine äußere Instanz vom Typ '{0}' im Gültigkeitsbereich
MSG_EXPECTING_CONDITION_FOR_ASSERT = Bedingung für 'assert' wird erwartet
MSG_EXPECTING_MESSAGE_FOR_ASSERT = Meldung für "assert" wird erwartet.
MSG_ASSERTIONS_NOT_ALLOWED_HERE = Die Anweisung "assert" ist hier nicht zulässig.
MSG_ARRAY_NOT_SUPPORTED = Array-Typ wird für {0} nicht unterstützt.
MSG_IMPROPER_USE_OF_KEYWORD = Unsachgemäße Verwendung des Schlüsselwortes, {0}
MSG_USES_STMT_CONFLICT = Typ {0} wird bereits verwendet
MSG_USES_STMT_DUPLICATE = Duplikat verwendet Anweisung
MSG_ARRAY_INDEX_MUST_BE_INT = Arrays müssen mit einem Ganzzahlwert indiziert werden.
MSG_PARAM_TYPE_CANT_BE_INFERRED_FROM_LATE_BOUND_EXPRESSION = Der Parametertyp kann nicht aus dem später verbindlich gemachten Ausdruckstypen ermitteln werden.
MSG_LOSS_OF_PRECISION_IN_NUMERIC_LITERAL = Dieses doppelte Literal verliert in diesem Vorgang Genauigkeit. Sie müssen es vielmehr explizit als BigDecimal deklarieren\: {0}
MSG_COMPILE_TIME_ANNOTATION_FAILED_TO_EXECUTE = Eine Kompilierungs-Annotation konnte nicht ausgeführt werden. Die Meldung war {0}. Beachten Sie die Konsole für Stack Trace.
MSG_METHOD_REIFIES_TO_SAME_SIGNATURE_AS_ANOTHER_METHOD = Eine Methode mit dem gleichen Namen besitzt eine Reifikation in der gleichen Signatur auf Bytecode-Ebene. Benennen Sie eine der Methoden um.
MSG_TYPE_NOT_REIFIED = {0} muss mit dem "reified"-Modifikator deklariert werden, um zur Laufzeit auf die Typenvariable "{1}" zuzugreifen.
MSG_REIFIED_DONT_MATCH = Funktion muss mit der gleichen "reified"-Einstellung überschrieben werden
MSG_REIFIED_DONT_MATCH_JAVA = Generische Reified-Methode {0} überschreibt eine Java-Methode in {1}. Durch Aufrufen von {0} aus {1} werden Typenparameter gelöscht.
NOTHING_TO_REIFY = Nichts zu reifizieren
MSG_PROPERTY_AND_FUNCTION_CONFLICT = Die Methode {0} steht im Konflikt zu den impliziten Methoden, die von der Eigenschaft {1} erzeugt werden.
MSG_PROPERTY_AND_FUNCTION_CONFLICT_UPON_REIFICATION = Die Methode {0} steht im Konflikt zu den impliziten Methoden, die von der Eigenschaft {1} nach Reifikation erzeugt werden.
MSG_CANNOT_OVERRIDE_FUNCTION_FROM_ENHANCEMENT = Eine in einer Erweiterung definierte Methode kann nicht überschrieben werden.
MSG_MASKING_ENHANCEMENT_METHODS_MAY_BE_CONFUSING = Diese Methode maskiert eine Methode, die in einer Erweiterung dieses Typs definiert wurde. Das kann zu einer unklaren Semantik führen, denn die Dispatcher der Erweiterungsmethoden arbeiten statisch.
MSG_STRING_COERCION_ON_RHS_OF_ADDITIVE_EXPRESSION_MUST_BE_PARENTHESIZED = Das Casting an einen String mit einem summierenden Ausdruck kann unklar sein. Parenthesieren Sie bitte den Ausdruck, um in korrekt zu beurteilen.
MSG_EXPLICIT_TYPE_RECOMMENDED_FOR_CATCH_STMTS = Hier sollte ein expliziter caught-Typ hinzugefügt werden.
MSG_SUPER_NOT_ACCESSIBLE_FROM_BLOCK = Auf das Supersymbol kann von innerhalb eines Blocks nicht zugegriffen werden.
MSG_GENERIC_PROPERTIES_NOT_SUPPORTED = Die Eigenschaften können keine Typenvariablen haben.
MSG_GENERIC_ANNOTATIONS_NOT_SUPPORTED = Annotationen können keine Typenvariablen haben.
MSG_CATCH_STMT_CANNOT_EXECUTE = Dieses Catch-Statement wird nie ausgeführt werden, da ein vorausgehendes Catch-Statement bereits die Ausnahmen dieser Art erfasst.
MSG_IMONITOR_LOCK_SHOULD_ONLY_BE_USED_WITHIN_USING_STMTS = Die IMonitorLock-Schnittstelle kann nur innerhalb von Ausdrücken verwendet werden, bei denen Statements für die Synchronisierung vom Legacy-Typ eingesetzt werden.
MSG_STATIC_MODIFIER_NOT_ALLOWED_HERE = Der "statische" Modifikator ist hier nicht zulässig.
MSG_MODIFIERS_NOT_ALLOWED_HERE = Modifikatoren sind hier unzulässig.
MSG_CANNOT_INSTANTIATE_NON_STATIC_CLASSES_HERE = Eine nicht statische Klasse kann hier nicht instantiiert werden.
MSG_WARN_ON_SUSPICIOUS_THIS_COMPARISON = Hier liegt anscheinend ein schlechter Vergleich vor. In gosu ist der Operator "\=\=" gleichwertig zu ".equals()". Möchten Sie eine Instanzäquivalenz erreichen, verwenden Sie den Operator "\=\=\=".
MSG_FL_EXPECTING_FEATURE_NAME = Hier wird ein Feature-Name erwartet, entweder der Name einer Methode, einer Eigenschaft oder "construct".
MSG_FL_EXPECTING_RIGHT_CARET = ">" wird erwartet.
MSG_FL_GENERIC_FUNCTION_REFERENCES_NOT_YET_SUPPORTED = Generische Funktionsliterale werden noch nicht unterstützt.
MSG_FL_EXPECTING_RIGHT_PAREN = Es wird ")" erwartet, um die Liste der Argumenttypen zu schließen.
MSG_FL_CONSTRUCTOR_NOT_FOUND = Ein Konstruktor mit den Typen {0} wurde nicht gefunden.
MSG_FL_METHOD_NOT_FOUND = Eine Methode mit dem Namen {0} und den Typen {1} wurde nicht gefunden.
MSG_FL_PROPERTY_NOT_FOUND = Eine Eigenschaft mit dem Namen {0} wurde nicht gefunden.
MSG_FL_STATIC_FEATURES_MUST_BE_REFERENCED_FROM_THEIR_TYPES = Ein statisches Feature oder ein Konstruktor muss einen direkten Bezug zu dem Typ besitzen, dem das Feature angehört.
MSG_NO_TYPE_AFTER_CONSTRUCTOR = Konstuktoren können keinen Rückgabetypen vorgeben.
WS_ERR_Can_Not_Marshal = {0} kann den lokalen Typ {2} für {1} nicht anordnen.
WS_ERR_Annotation_Duplicate_Namespace = Bei {0}\: Doppelter Namensraum „{1}“ bereits in „{2}“ verwendet. {3} versucht, ihn für {4} erneut einzuführen.
WS_ERR_Annotation_Exception = Eigenschaften vom Typ {0} werden ignoriert. Siehe Log für Stack Trace.
WS_ERR_Annotation_Invalid_Namespace = {0}\: Ungültiger Namensraum „{1}“
WS_ERR_Annotation_Only_For_WebService = {0}\: Die Annotation @{1} kann nur in Klassen verwendet werden, die mit @WsiWebService annotiert sind.
WS_ERR_Annotation_Operation_Duplicate = Bei {0}\: Methode {1}, es ist bereits eine Methode mit diesem Namen vorhanden
WS_ERR_Annotation_Operation_OneWay_Invalid = Methoden in eine Richtung müssen leere Rückgabetypen haben.
WS_ERR_Annotation_Operation_Response_Reserved = Bei {0}\: Methode {1}, das Suffix „Response“ ist für Antwortelemente reserviert
WS_ERR_Export_Inner_Only_On_WebService = Bei {0}\: Innere Klassen vom Typ {1} können nicht exportiert werden
WS_ERR_Export_Inner_Not_Name_Of_Method = Innere Klassen haben den gleichen Namen wie den für die Methode {0} angefragten.
WS_ERR_Export_Inner_Not_Name_Of_Response = Innere Klassen haben den gleichen Namen wie die Antwort auf die Methode {0}.
WS_ERR_Export_No_Constructor = Bei {0}\: Typ {1}, eine exportierbare Klasse benötigt einen öffentlichen Standardkonstruktor
WS_ERR_Export_No_Extends = Bei {0}\: Typ {1}, eine exportierbare Klasse kann keine andere Klasse erweitern.
WS_ERR_Export_Not_Final = Bei {0}\: Typ {1} ist nicht final. Eine exportierbare Klasse muss final sein
WS_ERR_Export_Not_WebService = Bei {0}\: Typ {1} ist ein Webdienst. Ein Webdienst darf nicht exportierbar sein
WS_ERR_Export_Recursive = Rekursion wird nicht unterstützt; stellen Sie sicher, dass {0} nicht rekursiv ist.
WS_WARN_Annontation_Some_Generators_Dont_Support_Schema = Warnung {0} bei der Verarbeitung des Parameters {1}; einige Webdienst-Frameworks können {2} evtl. nicht verstehen
WS_WARN_Annontation_Not_Available = {0} steht bis {1} nicht zur Verfügung.
WS_WARN_Ignored = {0}\: Wird Eigenschaft {1} vom Typ {2} ignorieren.
PCF_ERR_Verify = Bei der Prüfung von {0} ist ein PCF-Fehler aufgetreten.
MSG_FL_ONLY_PROPERTIES_MAY_BE_CHAINED = Nur Eigenschaftsliterale dürfen verkettet sein.
Gen_Wsi_InvalidType = {0} kann {1} nicht anordnen\: {2}
Gen_Wsi_UnsupportedType = {0} ist ein gültiger Typ, aber mit Webdiensten nicht unterstützt.
Gen_Wsi_UnsupportedComponentType = {0} wird nicht unterstützt, da der Komponenten-/Parametertyp nicht unterstützt wird.
Gen_Wsi_NoComponentType = {0} wird nicht unterstützt, da kein Komponenten-/Parametertyp angegeben.
Gen_Wsi_NoBase = XmlBase-Klasse {0} wird nicht direkt unterstützt.
Gen_Wsi_AnonElement = 0} anonyme Elemente werden unterstützt. Anonyme Elemente sind einem anderen Element untergeordnet. Sie können versuchen, den Typ des untergeordneten Elements zu verwenden.
Gen_Wsi_AnonType = {0} Anonyme Typen (in Elementdeklaration deklarierte Typen) werden nicht unterstützt. Sie können versuchen, das Element zu verwenden.
Gen_Wsi_NoSimple = {0} Einfache XSD-Typen werden nicht unterstützt. Sie können versuchen, einen komplexen Typ zu erstellen oder den erweiterten Typ zu verwenden.
Gen_Wsi_XmlError = Unerwarteter Fehler bei der Verarbeitung von {0}\: {1}
Gen_Wsi_NullType = Null-Typ übergeben
Gen_Wsi_TypeNotGosu = {0} ist nicht Gosu und wird daher nicht von WSI-Implementierung unterstützt.
Gen_Wsi_TypeNotWSAnnotated = {0} hat keine @WsiWebService-Annotation.
Gen_Wsi_TypeNotEXPAnnotated = {0} hat keine @WsiExportable-Annotation.
GEN_CAN_NOT_MARSHAL_GOSU_REMOTEABLE_ENUMS = {0} kann in Gosu geschriebene GWEnumerations nicht anordnen
GEN_CAN_NOT_MARSHAL_REMOTEABLE_ENUMS_EXTENDED = {0} kann GWEnumerations mit zusätzlichen Eigenschaften nicht anordnen
GEN_CAN_NOT_MARSHAL_XML_IN_EXPORTABLE = {0} kann XML in WsiExportable-Typen nicht anordnen
GEN_CLASS_CANNOT_BE_BOTH_WS_AND_EXPORT = Klasse {0} kann nicht sowohl @WsiWebService als auch {1} sein
GEN_CHECKING = {0} wird geprüft
GEN_CHANGED = {0} geändert
WS_ERR_Invalid_Supertype = {0} erweitert {1} nicht.
WS_ERR_Export_Empty = {0} hat keine exportierbaren Eigenschaften
WS_ERR_Previous_Invalid = {0} ist ungültig; Fehler bereits gemeldet
WS_ERR_Entity_Invalid = {0} ist ungültig. Anordnende Entitäten werden nicht unterstützt; erstellen Sie eine WsiExportable-Klasse mit den erforderlichen Feldern.
WS_ERR_Collection_Invalid = {0} ist ungültig. Nur Arrays und Liste <T> werden unterstützt.
WF_WARN_Subtype = Arbeitsablauf-Untertyp „{0}“ ist als nicht extern definiert, aber entweder wurde kein Skript definiert oder das Parsen des Skripts ist fehlgeschlagen. Überprüfen Sie die Protokolle auf Parsing-Fehler.
WF_ERR_Duplicate = Mehr als ein Arbeitsablaufprozess mit identischem Typencode „{0}“ und identischer Version „{1}“ definiert.
WF_ERR_Parse = „{0}“ konnte nicht geparst werden – {1}\: {2}
WF_ERR_Convert = „{0}“ konnte nicht konvertiert werden – {1}\: {2}
WF_ERR = Bei "{0}"\: {1}
